<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Lawis.at Avalanche Dashboard</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
  <style>
    body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 20px; background: #f0f2f5; }
    .container { max-width: 1100px; margin: auto; background: white; padding: 25px; border-radius: 10px; box-shadow: 0 2px 15px rgba(0,0,0,0.1); }
    .controls { display: flex; gap: 15px; margin-bottom: 25px; align-items: flex-end; border-bottom: 1px solid #eee; padding-bottom: 20px; }
    .charts-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px; }
    .chart-box { border: 1px solid #ddd; padding: 15px; border-radius: 8px; background: #fff; }
    .full-width { grid-column: 1 / -1; }
    .section-title { grid-column: 1 / -1; margin-top: 25px; border-top: 2px solid #1d3557; padding-top: 15px; color: #1d3557; }
    button { padding: 10px 20px; background: #1d3557; color: white; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; }
    button:disabled { background: #999; }
    #status { font-weight: bold; color: #1d3557; }
    #progress { font-size: 0.85em; color: #666; }
  </style>
</head>
<body>

<div class="container">
  <h2>Avalanche Incident Dashboard (Tirol)</h2>
  
  <div class="controls">
    <div><label>Start:</label><br><input type="date" id="startDate" value="2024-11-01" /></div>
    <div><label>End:</label><br><input type="date" id="endDate" value="2025-06-01" /></div>
    <button id="btnFetch">Start Analysis</button>
  </div>

  <p id="status">Ready.</p>
  <p id="progress"></p>

  <div class="charts-grid">
    <div class="chart-box full-width"><canvas id="timelineChart"></canvas></div>
    
    <div class="chart-box"><canvas id="aspectChart"></canvas></div>
    <div class="chart-box"><canvas id="hourChart"></canvas></div>

    <h3 class="section-title">Risk & Survival Factors (Filtered Data)</h3>
    <div class="chart-box"><canvas id="slopeChart"></canvas></div>
    <div class="chart-box"><canvas id="dangerMortalityChart"></canvas></div>
    <div class="chart-box"><canvas id="lvsOutcomeChart"></canvas></div>
    <div class="chart-box"><canvas id="gearMatrixChart"></canvas></div>
  </div>
</div>

<script>
let charts = {};
const proxy = "https://corsproxy.io/?";
const sleep = ms => new Promise(res => setTimeout(res, ms));

async function startScrape() {
  const start = document.getElementById('startDate').value;
  const end = document.getElementById('endDate').value;
  const btn = document.getElementById('btnFetch');
  const status = document.getElementById('status');
  const progress = document.getElementById('progress');

  btn.disabled = true;
  status.innerText = "Fetching list...";

  try {
    const listUrl = `https://lawis.at/lawis_api/public/incident?startDate=${start}&endDate=${end}`;
    const resp = await fetch(proxy + encodeURIComponent(listUrl));
    const all = await resp.json();
    const tyrolOnly = all.filter(i => i.location?.country?.code === "AT" && i.location?.region?.text === "Tirol");

    status.innerText = `Found ${tyrolOnly.length} incidents. Loading details...`;
    const finalData = [];

    for (let i = 0; i < tyrolOnly.length; i++) {
      const inc = tyrolOnly[i];
      progress.innerText = `Processing ID: ${inc.id} (${i+1}/${tyrolOnly.length})`;

      try {
        const detailUrl = `https://lawis.at/lawis_api/public/incident/${inc.id}`;
        const detailResp = await fetch(proxy + encodeURIComponent(detailUrl));
        const body = await detailResp.json();
        
        const inv = body.involved || {};
        const dgr = body.danger || {};
        
        const dead = parseInt(inv.dead) || 0;
        const injured = parseInt(inv.injured) || 0;
        const uninjured = parseInt(inv.uninjured) || 0;
        const swept = parseInt(inv.sweeped) || 0;

        // Unknown status calculation
        const knownOutcomes = dead + injured + uninjured;
        const unknownStatus = Math.max(0, swept - knownOutcomes);
        const involvedCount = Math.max(swept, knownOutcomes);

        const incidentDate = new Date(inc.date);

        // STRIKT SLOPE PARSING: Verwijder tekst en check op validiteit
        const rawSlope = inc.location?.slope_angle;
        let slopeVal = null;
        if (rawSlope) {
            const parsed = parseFloat(rawSlope.toString().replace(/[^\d.-]/g, ''));
            if (!isNaN(parsed) && parsed > 0) slopeVal = parsed;
        }

        finalData.push({
          date: incidentDate,
          hour: incidentDate.getHours(),
          dead, injured, uninjured, unknownStatus, involvedCount,
          slope: slopeVal,
          aspect: inc.location?.aspect?.text || null,
          dangerLevel: parseInt(dgr.rating?.level) || null,
          lvs: inv.equipment?.lvs?.text?.toLowerCase() || "unknown",
          airbag: inv.equipment?.airbag?.text?.toLowerCase() || "none"
        });

        await sleep(5); 
      } catch (e) { console.warn("Error at ID", inc.id); }
    }

    status.innerText = "Analysis Complete!";
    progress.innerText = "";
    renderCharts(finalData);

  } catch (err) {
    status.innerText = "Error: " + err.message;
  } finally { btn.disabled = false; }
}

function renderCharts(data) {
  renderTimeline(data);
  renderAspect(data);
  renderHourClock(data);
  renderSlope(data);
  renderDangerMortality(data);
  renderLvsOutcome(data);
  renderGearMatrix(data);
}

function renderTimeline(data) {
  const ctx = document.getElementById('timelineChart').getContext('2d');
  if (charts.time) charts.time.destroy();

  // We mappen de data naar een "fictief" jaar (2024) voor de X-as
  // Maar we bewaren de echte datum voor de tooltip
  const seasonalData = data.map(d => {
    const virtualDate = new Date(d.date);
    // Als de maand okt-dec is, zetten we het in 'jaar 1', jan-aug in 'jaar 2'
    // Zo behouden we de logische wintervolgorde
    const yearOffset = virtualDate.getMonth() >= 9 ? 2024 : 2025;
    virtualDate.setFullYear(yearOffset);
    
    return {
      ...d,
      x: virtualDate,
      realDate: d.date.toLocaleDateString('nl-NL')
    };
  });

  charts.time = new Chart(ctx, {
    type: 'bar',
    data: {
      datasets: [
        {
          label: 'Dead',
          data: seasonalData.filter(d => d.dead > 0).map(d => ({ x: d.x, y: d.dead, realDate: d.realDate })),
          backgroundColor: '#000',
          stack: 'v', barThickness: 6
        },
        {
          label: 'Injured',
          data: seasonalData.filter(d => d.injured > 0).map(d => ({ x: d.x, y: d.injured, realDate: d.realDate })),
          backgroundColor: '#e63946',
          stack: 'v', barThickness: 6
        }
      ]
    },
    options: {
      responsive: true,
      plugins: {
        title: { display: true, text: 'Season overview (all years overlaid)' },
        tooltip: {
          callbacks: {
            title: (items) => "Date: " + items[0].raw.realDate,
            label: (item) => `${item.dataset.label}: ${item.raw.y}`
          }
        }
      },
      scales: {
        x: { 
          type: 'time', 
          time: { 
            unit: 'month',
            displayFormats: { month: 'MMM' }
          },
          title: { display: true, text: 'Season' }
        },
        y: { stacked: true, beginAtZero: true }
      }
    }
  });
}

function renderHourClock(data) {
  const ctx = document.getElementById('hourChart').getContext('2d');
  if (charts.hour) charts.hour.destroy();
  const hours = Array.from({length: 24}, (_, i) => i);
  const hourCounts = hours.map(h => data.filter(d => d.hour === h).length);
  charts.hour = new Chart(ctx, {
    type: 'radar',
    data: {
      labels: hours.map(h => h + 'h'),
      datasets: [{
        label: 'Incidents',
        data: hourCounts,
        backgroundColor: 'rgba(230, 57, 70, 0.2)',
        borderColor: '#e63946',
        pointBackgroundColor: '#e63946'
      }]
    },
    options: {
      plugins: { title: { display: true, text: 'Time of Day (24h)' } },
      scales: { r: { beginAtZero: true, ticks: { display: false } } }
    }
  });
}

function renderAspect(data) {
  const ctx = document.getElementById('aspectChart').getContext('2d');
  if (charts.aspect) charts.aspect.destroy();
  const order = ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW'];
  charts.aspect = new Chart(ctx, {
    type: 'polarArea',
    data: { labels: order, datasets: [{ data: order.map(a => data.filter(d => d.aspect === a).length), backgroundColor: 'rgba(69, 123, 157, 0.6)' }] },
    options: { plugins: { title: { display: true, text: 'Slope Aspect' } } }
  });
}

function renderSlope(data) {
  const ctx = document.getElementById('slopeChart').getContext('2d');
  if (charts.slope) charts.slope.destroy();

  // FILTER: Alleen incidenten met een bekende, valide hellingshoek
  const validData = data.filter(d => d.slope !== null);

  const labels = ['<30°', '30-35°', '35-40°', '40-45°', '45°+'];
  const counts = [
    validData.filter(d => d.slope < 30).length,
    validData.filter(d => d.slope >= 30 && d.slope < 35).length,
    validData.filter(d => d.slope >= 35 && d.slope < 40).length,
    validData.filter(d => d.slope >= 40 && d.slope < 45).length,
    validData.filter(d => d.slope >= 45).length
  ];

  charts.slope = new Chart(ctx, {
    type: 'bar',
    data: { labels, datasets: [{ label: 'Incidents', data: counts, backgroundColor: '#1d3557' }] },
    options: { plugins: { title: { display: true, text: 'Slope Steepness (Known Values Only)' } } }
  });
}

function renderDangerMortality(data) {
  const ctx = document.getElementById('dangerMortalityChart').getContext('2d');
  if (charts.danger) charts.danger.destroy();
  const levels = [1, 2, 3, 4, 5];
  const colors = ['#2ecc71', '#f1c40f', '#e67e22', '#e74c3c', '#000000'];
  const mortalityRates = levels.map(lvl => {
    const subset = data.filter(d => d.dangerLevel === lvl);
    const total = subset.reduce((s, d) => s + d.involvedCount, 0);
    const dead = subset.reduce((s, d) => s + d.dead, 0);
    return total > 0 ? (dead / total) * 100 : 0;
  });
  charts.danger = new Chart(ctx, {
    type: 'bar',
    data: { labels: levels.map(l => `Level ${l}`), datasets: [{ label: 'Mortality %', data: mortalityRates, backgroundColor: colors }] },
    options: { plugins: { title: { display: true, text: 'Mortality Rate by Danger Level' } } }
  });
}

function renderLvsOutcome(data) {
  const ctx = document.getElementById('lvsOutcomeChart').getContext('2d');
  if (charts.lvs) charts.lvs.destroy();
  const groups = ['yes', 'no'];
  charts.lvs = new Chart(ctx, {
    type: 'bar',
    data: {
      labels: ['LVS Used', 'No LVS'],
      datasets: [
        { label: 'Dead', backgroundColor: '#000000', data: groups.map(g => data.filter(d => d.lvs === g).reduce((s, d) => s + d.dead, 0)) },
        { label: 'Injured', backgroundColor: '#e63946', data: groups.map(g => data.filter(d => d.lvs === g).reduce((s, d) => s + d.injured, 0)) },
        { label: 'Uninjured', backgroundColor: '#a8dadc', data: groups.map(g => data.filter(d => d.lvs === g).reduce((s, d) => s + d.uninjured, 0)) },
        { label: 'Unknown', backgroundColor: '#bdc3c7', data: groups.map(g => data.filter(d => d.lvs === g).reduce((s, d) => s + d.unknownStatus, 0)) }
      ]
    },
    options: { indexAxis: 'y', scales: { x: { stacked: true }, y: { stacked: true } }, plugins: { title: { display: true, text: 'Outcome Breakdown (Stacked)' } } }
  });
}

function renderGearMatrix(data) {
  const ctx = document.getElementById('gearMatrixChart').getContext('2d');
  if (charts.risk) charts.risk.destroy();
  const combos = [
    { label: 'No Gear', filter: d => d.lvs === 'no' && d.airbag === 'none' },
    { label: 'LVS Only', filter: d => d.lvs === 'yes' && d.airbag === 'none' },
    { label: 'LVS + Airbag', filter: d => d.lvs === 'yes' && d.airbag === 'all' }
  ];
  const rates = combos.map(c => {
    const subset = data.filter(c.filter);
    const total = subset.reduce((s, d) => s + d.involvedCount, 0);
    const dead = subset.reduce((s, d) => s + d.dead, 0);
    return total > 0 ? Math.round((dead / total) * 100) : 0;
  });
  charts.risk = new Chart(ctx, {
    type: 'bar',
    data: { labels: combos.map(c => c.label), datasets: [{ label: 'Fatality Rate %', data: rates, backgroundColor: '#1d3557' }] },
    options: { plugins: { title: { display: true, text: 'Survival Risk Matrix (% Mortality)' } } }
  });
}

document.getElementById('btnFetch').addEventListener('click', startScrape);
</script>

</body>
</html>