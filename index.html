<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Avalanche Incident Dashboard Tirol</title>

  <!-- Typography -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Fraunces:opsz,wght@9..144,600;9..144,700&family=Inter:wght@400;500;600&display=swap" rel="stylesheet">

  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>

  <style>
    :root{
      --slate: #6E8387;
      --pink:  #F4C3C2;
      --blush: #F3DAD8;
      --ink:   #231C07;
      --berry: #D11149;

      --bg: #f6f7f7;
      --card: #ffffff;
      --border: rgba(35, 28, 7, 0.14);
      --shadow: 0 10px 30px rgba(35, 28, 7, 0.10);
      --radius: 14px;
    }

    * { box-sizing: border-box; }
    body {
      font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      margin: 20px;
      color: rgba(35, 28, 7, 0.88);
      background:
        radial-gradient(1200px 600px at 15% 0%, var(--blush), transparent 60%),
        radial-gradient(900px 500px at 100% 10%, rgba(110,131,135,0.18), transparent 60%),
        var(--bg);
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    .container {
      max-width: 1100px;
      margin: auto;
      background: var(--card);
      padding: 22px;
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      border: 1px solid var(--border);
    }

    h2 {
      font-family: Fraunces, Georgia, serif;
      font-weight: 700;
      letter-spacing: -0.02em;
      margin: 0 0 14px;
      color: #231C07;
      font-size: 30px;
      line-height: 1.15;
    }

    .controls {
      display: flex;
      gap: 14px;
      margin-bottom: 18px;
      align-items: flex-end;
      border-bottom: 1px solid var(--border);
      padding-bottom: 16px;
    }

    label { font-size: 12px; color: rgba(35, 28, 7, 0.70); font-weight: 600; }
    input[type="date"]{
      margin-top: 6px;
      padding: 10px 12px;
      border: 1px solid var(--border);
      border-radius: 10px;
      background: #fff;
      font: inherit;
      color: #231C07;
      outline: none;
      width: 100%;
    }
    input[type="date"]:focus{
      border-color: rgba(209, 17, 73, 0.55);
      box-shadow: 0 0 0 4px rgba(209, 17, 73, 0.12);
    }

    button {
      padding: 11px 18px;
      background: var(--berry);
      color: white;
      border: none;
      border-radius: 12px;
      cursor: pointer;
      font-weight: 700;
      letter-spacing: 0.01em;
      transition: transform .06s ease, filter .15s ease, opacity .15s ease;
      width: 100%;
    }
    button:hover { filter: brightness(0.97); }
    button:active { transform: translateY(1px); }
    button:disabled { opacity: 0.55; cursor: not-allowed; }

    /* Smaller utility button (for toggle) */
    .btn-small{
      width: auto !important;
      padding: 9px 12px !important;
      border-radius: 12px !important;
      font-weight: 700;
    }

    #status { font-weight: 600; color: rgba(35, 28, 7, 0.85); margin: 8px 0 2px; }
    #progress { font-size: 0.9em; color: rgba(35, 28, 7, 0.55); margin: 0 0 10px; }

    .charts-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 16px;
      margin-bottom: 8px;
    }

    .chart-box {
      border: 1px solid var(--border);
      padding: 14px;
      border-radius: var(--radius);
      background: linear-gradient(180deg, rgba(243,218,216,0.22), rgba(243,218,216,0.02));
      box-shadow: 0 6px 16px rgba(35, 28, 7, 0.06);
      position: relative;
      overflow: hidden;

      /* CRISP charts: size the container, not the canvas */
      height: 360px;
    }
    .chart-box.full-width { grid-column: 1 / -1; height: 440px; }

    .chart-box canvas{
      width: 100% !important;
      height: 100% !important;
      display: block;
    }

    .section-title {
      grid-column: 1 / -1;
      margin: 12px 0 -4px;
      border-top: 1px solid var(--border);
      padding-top: 14px;
      color: rgba(35, 28, 7, 0.88);
      font-family: Fraunces, Georgia, serif;
      letter-spacing: -0.01em;
    }

    /* Phone responsiveness */
    @media (max-width: 900px){
      .charts-grid { grid-template-columns: 1fr; }
    }
    @media (max-width: 700px){
      .controls { flex-direction: column; align-items: stretch; }
      .controls > div { width: 100%; }
      .timeline-head { flex-direction: column; align-items: stretch !important; gap: 8px !important; }
      .timeline-head .btn-small { width: 100% !important; }
    }
    @media (max-width: 420px){
      .container { padding: 16px; }
      h2 { font-size: 22px; }
      .chart-box { height: 320px; }
      .chart-box.full-width { height: 380px; }
    }
  </style>
</head>
<body>

<div class="container">
  <h2>Avalanche Incident Dashboard (Tirol)</h2>

  <div class="controls">
    <div style="flex:1"><label>Start</label><br><input type="date" id="startDate" value="2024-11-01" /></div>
    <div style="flex:1"><label>End</label><br><input type="date" id="endDate" value="2025-06-01" /></div>
    <div style="width: 220px; max-width: 100%"><button id="btnFetch">Start Analysis</button></div>
  </div>

  <p id="status">Ready.</p>
  <p id="progress"></p>

  <div class="charts-grid">
    <!-- Timeline (toggle: stacked outcomes <-> danger bubbles) -->
    <div class="chart-box full-width">
      <div class="timeline-head" style="display:flex; justify-content:space-between; align-items:center; gap:10px; margin-bottom:10px;">
        <div style="font-family:Fraunces, Georgia, serif; font-weight:700; color:#231C07;">
          Season timeline
        </div>
        <button id="btnToggleTimeline" type="button" class="btn-small">
          Show danger bubbles
        </button>
      </div>
      <canvas id="timelineChart"></canvas>
    </div>

    <div class="chart-box"><canvas id="aspectChart"></canvas></div>
    <div class="chart-box"><canvas id="hourChart"></canvas></div>

    <h3 class="section-title">Risk & Survival Factors</h3>
    <div class="chart-box"><canvas id="slopeChart"></canvas></div>
    <div class="chart-box"><canvas id="dangerMortalityChart"></canvas></div>
    <div class="chart-box"><canvas id="lvsOutcomeChart"></canvas></div>
    <div class="chart-box"><canvas id="gearMatrixChart"></canvas></div>
  </div>
</div>

<script>
let charts = {};
let currentTimelineMode = "stacked"; // "stacked" | "bubble"
let latestData = [];

const proxy = "https://corsproxy.io/?";
const sleep = ms => new Promise(res => setTimeout(res, ms));

/* Palette */
const PALETTE = {
  slate: "#6E8387",
  pink:  "#F4C3C2",
  blush: "#F3DAD8",
  ink:   "#231C07",
  berry: "#D11149"
};

/* Global Chart.js aesthetics + crisp rendering */
Chart.defaults.font.family = "Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif";
Chart.defaults.color = "rgba(35, 28, 7, 0.78)";
Chart.defaults.borderColor = "rgba(35, 28, 7, 0.12)";
Chart.defaults.plugins.title.display = true;
Chart.defaults.plugins.title.color = PALETTE.ink;
Chart.defaults.plugins.title.font = { family: "Fraunces, Georgia, serif", size: 15, weight: "700" };
Chart.defaults.plugins.legend.labels.usePointStyle = true;
Chart.defaults.plugins.legend.labels.boxWidth = 10;
Chart.defaults.maintainAspectRatio = false;
Chart.defaults.devicePixelRatio = window.devicePixelRatio || 1;

function gridColor(alpha=0.08){ return `rgba(35, 28, 7, ${alpha})`; }

/**
 * STRICT ENUM NORMALIZERS
 * airbag:  "unknown" | "some" | "none" | "all"
 * lvs:     "unknown" | "no" | "yes"
 */
function normAirbag(v) {
  const s = (v ?? "").toString().trim().toLowerCase();
  return (s === "some" || s === "none" || s === "all") ? s : "unknown";
}
function normLvs(v) {
  const s = (v ?? "").toString().trim().toLowerCase();
  return (s === "yes" || s === "no") ? s : "unknown";
}

/* Danger level mapping per your scheme:
   1,2,3,4 are real levels
   7 = no avalanche report that day
   NA/unknown/null -> 0
*/
function dangerToY(level) {
  const v = parseInt(level);

  // display order:
  // 0 = Unknown
  // 1 = No report
  // 2..6 = Level 1..5
  if (v === 7) return 1;                 // No report
  if (v === 1 || v === 2 || v === 3 || v === 4 || v === 5) return v + 1; // shift up
  return 0;                              // Unknown
}


function dangerLabel(y) {
  if (y === 0) return "Unknown";
  if (y === 1) return "No report";
  return `Level ${y - 1}`;
}


async function startScrape() {
  const start = document.getElementById('startDate').value;
  const end = document.getElementById('endDate').value;
  const btn = document.getElementById('btnFetch');
  const status = document.getElementById('status');
  const progress = document.getElementById('progress');

  btn.disabled = true;
  status.innerText = "Fetching list...";

  try {
    const listUrl = `https://lawis.at/lawis_api/public/incident?startDate=${start}&endDate=${end}`;
    const resp = await fetch(proxy + encodeURIComponent(listUrl));
    const all = await resp.json();

    const tyrolOnly = all.filter(i =>
      i.location?.country?.code === "AT" &&
      i.location?.region?.text === "Tirol"
    );

    status.innerText = `Found ${tyrolOnly.length} incidents. Loading details...`;
    const finalData = [];

    for (let i = 0; i < tyrolOnly.length; i++) {
      const inc = tyrolOnly[i];
      progress.innerText = `Processing ID: ${inc.id} (${i + 1}/${tyrolOnly.length})`;

      try {
        const detailUrl = `https://lawis.at/lawis_api/public/incident/${inc.id}`;
        const detailResp = await fetch(proxy + encodeURIComponent(detailUrl));
        const body = await detailResp.json();

        const inv = body.involved || {};
        const dgr = body.danger || {};

        const dead = parseInt(inv.dead) || 0;
        const injured = parseInt(inv.injured) || 0;
        const uninjured = parseInt(inv.uninjured) || 0;
        const swept = parseInt(inv.sweeped) || 0;

        const knownOutcomes = dead + injured + uninjured;
        const unknownStatus = Math.max(0, swept - knownOutcomes);
        const involvedCount = Math.max(swept, knownOutcomes);

        const incidentDate = new Date(inc.date);

        const rawSlope = inc.location?.slope_angle;
        let slopeVal = null;
        if (rawSlope) {
          const parsed = parseFloat(rawSlope.toString().replace(/[^\d.-]/g, ''));
          if (!isNaN(parsed) && parsed > 0) slopeVal = parsed;
        }

        const rawDanger = dgr.rating?.level;
        const dangerY = dangerToY(rawDanger);

        finalData.push({
          date: incidentDate,
          hour: incidentDate.getHours(),
          dead, injured, uninjured, unknownStatus, involvedCount,
          slope: slopeVal,
          aspect: inc.location?.aspect?.text || null,
          dangerLevelRaw: rawDanger ?? null,   // keep original
          dangerY,                             // normalized to 0/1/2/3/4/7
          lvs: normLvs(inv.equipment?.lvs?.text),
          airbag: normAirbag(inv.equipment?.airbag?.text)
        });

        await sleep(5);
      } catch (e) {
        console.warn("Error at ID", inc.id, e);
      }
    }

    status.innerText = "Analysis Complete!";
    progress.innerText = "";
    latestData = finalData;
    renderCharts(finalData);

  } catch (err) {
    status.innerText = "Error: " + err.message;
  } finally {
    btn.disabled = false;
  }
}

/* Toggle handler */
document.getElementById('btnToggleTimeline').addEventListener('click', () => {
  currentTimelineMode = (currentTimelineMode === "stacked") ? "bubble" : "stacked";
  document.getElementById('btnToggleTimeline').innerText =
    (currentTimelineMode === "stacked") ? "Show danger bubbles" : "Show stacked timeline";

  if (latestData.length) renderTimeline(latestData);
});

function renderCharts(data) {
  renderTimeline(data);     // ✅ wrapper (stacked by default)
  renderAspect(data);
  renderHourClock(data);
  renderSlope(data);
  renderDangerMortality(data);
  renderLvsOutcome(data);
  renderGearMatrix(data);
}

function renderTimeline(data) {
  if (currentTimelineMode === "bubble") renderDangerTimelineBubbles(data);
  else renderTimelineStacked(data);
}

/* ===== Timeline mode 1: OLD stacked outcomes (complete: dead/inj/uninj/unknown) ===== */
function renderTimelineStacked(data) {
  const ctx = document.getElementById('timelineChart').getContext('2d');
  if (charts.time) charts.time.destroy();

  const seasonalData = data.map(d => {
    const virtualDate = new Date(d.date);
    const yearOffset = virtualDate.getMonth() >= 9 ? 2024 : 2025;
    virtualDate.setFullYear(yearOffset);

    return {
      ...d,
      x: virtualDate,
      realDate: d.date.toLocaleDateString('nl-NL')
    };
  });

  charts.time = new Chart(ctx, {
    type: 'bar',
    data: {
      datasets: [
        { label: 'Dead',      data: seasonalData.map(d => ({ x:d.x, y:d.dead||0, realDate:d.realDate })),           backgroundColor: PALETTE.ink,   stack:'v', barThickness:6 },
        { label: 'Injured',   data: seasonalData.map(d => ({ x:d.x, y:d.injured||0, realDate:d.realDate })),        backgroundColor: PALETTE.berry, stack:'v', barThickness:6 },
        { label: 'Uninjured', data: seasonalData.map(d => ({ x:d.x, y:d.uninjured||0, realDate:d.realDate })),      backgroundColor: PALETTE.pink,  stack:'v', barThickness:6 },
        { label: 'Unknown',   data: seasonalData.map(d => ({ x:d.x, y:d.unknownStatus||0, realDate:d.realDate })),  backgroundColor: PALETTE.slate, stack:'v', barThickness:6 }
      ]
    },
    options: {
      layout: {
  padding: { top: 10, right: 6, bottom: 18, left: 6 }
},
      plugins: {
        title: { text: 'Season overview (stacked outcomes)' },
        tooltip: {
          callbacks: {
            title: (items) => "Date: " + items[0].raw.realDate,
            label: (item) => `${item.dataset.label}: ${item.raw.y}`
          }
        }
      },
      scales: {
        x: {
          type:'time',
          time:{ unit:'month', displayFormats:{ month:'MMM' } },
          title:{ display:true, text:'Season' },
          grid:{ color:gridColor(0.06) },
          ticks: {
      autoSkip: true,
      maxRotation: 0,
      padding: 8
    }
        },
        y: {
          stacked:true,
          beginAtZero:true,
          grid:{ color:gridColor(0.08) }
        }
      }
    }
  });
}

/* ===== Timeline mode 2: Danger vs season bubbles + danger bands ===== */
function severityColor(d) {
  if (d.dead > 0) return PALETTE.ink;
  if (d.injured > 0) return PALETTE.berry;
  if (d.uninjured > 0) return PALETTE.pink;
  if (d.unknownStatus > 0) return PALETTE.slate;
  return PALETTE.blush;
}
function bubbleRadius(involvedCount) {
  const n = Math.max(0, involvedCount || 0);
  return Math.min(16, 4 + Math.sqrt(n) * 2);
}

const dangerBandsPlugin = {
  id: 'dangerBands',
  beforeDraw(chart) {
    const { ctx, chartArea, scales } = chart;
    if (!chartArea || !scales?.y) return;

    const y = scales.y;
    const left = chartArea.left;
    const right = chartArea.right;

    // DISPLAY LEVELS:
    // 0 = Unknown (no band)
    // 1 = No report
    // 2..6 = Level 1..5
    const bandColors = {
      1: "rgba(35, 28, 7, 0.06)",      // No report (subtle ink wash)
      2: "rgba(243, 218, 216, 0.62)",  // Level 1 (blush)
      3: "rgba(244, 195, 194, 0.58)",  // Level 2 (pink)
      4: "rgba(110, 131, 135, 0.26)",  // Level 3 (slate)
      5: "rgba(209, 17, 73, 0.14)",    // Level 4 (berry light)
      6: "rgba(209, 17, 73, 0.26)"     // Level 5 (berry stronger) ✅ clearly different
    };

    ctx.save();
    [1,2,3,4,5,6].forEach(lvl => {
      // Clamp bands so nothing tries to draw beyond the scale
      const yTop = y.getPixelForValue(Math.min(6, lvl + 0.5));
      const yBot = y.getPixelForValue(Math.max(0, lvl - 0.5));
      ctx.fillStyle = bandColors[lvl];
      ctx.fillRect(left, yTop, right - left, yBot - yTop);
    });
    ctx.restore();
  }
};


function renderDangerTimelineBubbles(data) {
  const ctx = document.getElementById('timelineChart').getContext('2d');
  if (charts.time) charts.time.destroy();

  const seasonal = data.map(d => {
    const vd = new Date(d.date);
    const yearOffset = vd.getMonth() >= 9 ? 2024 : 2025;
    vd.setFullYear(yearOffset);

    return {
      ...d,
      x: vd,
      y: d.dangerY ?? 0,
      realDate: d.date.toLocaleDateString('nl-NL'),
      r: bubbleRadius(d.involvedCount),
      color: severityColor(d)
    };
  });

  charts.time = new Chart(ctx, {
    type: 'bubble',
    plugins: [dangerBandsPlugin],
    data: {
      datasets: [{
        label: 'Incidents',
        data: seasonal.map(p => ({ x:p.x, y:p.y, r:p.r, _raw:p })),
        backgroundColor: seasonal.map(p => p.color + "CC"),
        borderColor: "rgba(35, 28, 7, 0.18)",
        borderWidth: 1,
        hoverBorderColor: PALETTE.berry,
        hoverBorderWidth: 2
      }]
    },
    options: {
      layout: { padding: { top: 10, right: 6, bottom: 18, left: 6 } },   // Padding of the top plot such that axes arent cut
      plugins: {
        title: { text: 'Danger vs Season (bubble size ≈ involved)', padding: { top: 6, bottom: 10 } },
        legend: { display: false },
        tooltip: {
          callbacks: {
            title: (items) => `Date: ${items[0].raw._raw.realDate}`,
            label: (item) => {
              const p = item.raw._raw;
              return [
                `Danger: ${dangerLabel(p.y)}`,
                `Involved: ${p.involvedCount}`,
                `Dead / Injured / Uninjured / Unknown: ${p.dead} / ${p.injured} / ${p.uninjured} / ${p.unknownStatus}`,
                `LVS: ${p.lvs} · Airbag: ${p.airbag}`
              ];
            }
          }
        }
      },
      scales: {
        x: {
          type: 'time',
          time: { unit: 'month', displayFormats: { month: 'MMM' } },
          title: { display: true, text: 'Season' },
          grid: { color: gridColor(0.06) },
              ticks: {autoSkip: true,maxRotation: 0,padding: 8},
        },
        y: {
  min: -0.6,
  max: 6.6,
  ticks: {
    stepSize: 1,
    callback: (v) => {
      if (v === 0) return "Unknown";
      if (v === 1) return "No report";
      if (v >= 2 && v <= 6) return `Level ${v - 1}`;
      return "";
    }
  },
  title: { display: true, text: 'Danger Level' },
  grid: { color: gridColor(0.10) }
}


      }
    }
  });
}

/* ===== Other charts ===== */

function renderHourClock(data) {
  const ctx = document.getElementById('hourChart').getContext('2d');
  if (charts.hour) charts.hour.destroy();

  const hours = Array.from({ length: 24 }, (_, i) => i);
  const hourCounts = hours.map(h => data.filter(d => d.hour === h).length);

  charts.hour = new Chart(ctx, {
    type: 'radar',
    data: {
      labels: hours.map(h => h + 'h'),
      datasets: [{
        label: 'Incidents',
        data: hourCounts,
        backgroundColor: "rgba(209, 17, 73, 0.18)",
        borderColor: PALETTE.berry,
        pointBackgroundColor: PALETTE.berry,
        pointBorderColor: PALETTE.berry
      }]
    },
    options: {
      plugins: { title: { text: 'Time of Day (24h)' } },
      scales: {
        r: {
          beginAtZero: true,
          ticks: { display: false },
          grid: { color: gridColor(0.10) },
          angleLines: { color: gridColor(0.10) }
        }
      }
    }
  });
}

function renderAspect(data) {
  const ctx = document.getElementById('aspectChart').getContext('2d');
  if (charts.aspect) charts.aspect.destroy();

  const order = ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW'];
  const values = order.map(a => data.filter(d => d.aspect === a).length);

  charts.aspect = new Chart(ctx, {
    type: 'polarArea',
    data: {
      labels: order,
      datasets: [{
        data: values,
        backgroundColor: values.map(() => PALETTE.slate + "CC"),
        hoverBackgroundColor: values.map(() => PALETTE.berry + "CC"),
        borderColor: "rgba(35, 28, 7, 0.10)",
        borderWidth: 1
      }]
    },
    options: {
      plugins: {
        title: { text: 'Slope Aspect' },
        legend: { display: false },
        tooltip: { enabled: true }
      },
      scales: { r: { grid: { color: gridColor(0.10) }, ticks: { backdropColor: "transparent" } } }
    }
  });
}

function renderSlope(data) {
  const ctx = document.getElementById('slopeChart').getContext('2d');
  if (charts.slope) charts.slope.destroy();

  const validData = data.filter(d => d.slope !== null);

  const labels = ['<30°', '30-35°', '35-40°', '40-45°', '45°+'];
  const counts = [
    validData.filter(d => d.slope < 30).length,
    validData.filter(d => d.slope >= 30 && d.slope < 35).length,
    validData.filter(d => d.slope >= 35 && d.slope < 40).length,
    validData.filter(d => d.slope >= 40 && d.slope < 45).length,
    validData.filter(d => d.slope >= 45).length
  ];

  charts.slope = new Chart(ctx, {
    type: 'bar',
    data: { labels, datasets: [{ label: 'Incidents', data: counts, backgroundColor: PALETTE.slate }] },
    options: {
      plugins: { title: { text: 'Slope Steepness (Known Values Only)' } },
      scales: {
        x: { grid: { color: gridColor(0.06) } },
        y: { beginAtZero: true, grid: { color: gridColor(0.08) } }
      }
    }
  });
}

function renderDangerMortality(data) {
  const ctx = document.getElementById('dangerMortalityChart').getContext('2d');
  if (charts.danger) charts.danger.destroy();

  // your danger scheme
  const levels = [1, 2, 3, 4, 7, 0]; // 0 = NA/unknown, 7 = no report
  const labels = levels.map(l => dangerLabel(l));
  const colors = [PALETTE.blush, PALETTE.pink, PALETTE.slate, PALETTE.berry, PALETTE.ink, PALETTE.slate];

  const mortalityRates = levels.map(lvl => {
    const subset = data.filter(d => (d.dangerY ?? 0) === lvl);
    const total = subset.reduce((s, d) => s + d.involvedCount, 0);
    const dead = subset.reduce((s, d) => s + d.dead, 0);
    return total > 0 ? (dead / total) * 100 : 0;
  });

  charts.danger = new Chart(ctx, {
    type: 'bar',
    data: { labels, datasets: [{ label: 'Mortality %', data: mortalityRates, backgroundColor: colors }] },
    options: {
      plugins: { title: { text: 'Mortality Rate by Danger Level' } },
      scales: {
        x: { grid: { color: gridColor(0.06) } },
        y: { beginAtZero: true, grid: { color: gridColor(0.08) } }
      }
    }
  });
}

function renderLvsOutcome(data) {
  const ctx = document.getElementById('lvsOutcomeChart').getContext('2d');
  if (charts.lvs) charts.lvs.destroy();

  const groups = ['yes', 'no', 'unknown'];
  const labels = ['LVS Used', 'No LVS', 'Unknown'];

  charts.lvs = new Chart(ctx, {
    type: 'bar',
    data: {
      labels,
      datasets: [
        { label: 'Dead',      backgroundColor: PALETTE.ink,   data: groups.map(g => data.filter(d => d.lvs === g).reduce((s, d) => s + d.dead, 0)) },
        { label: 'Injured',   backgroundColor: PALETTE.berry, data: groups.map(g => data.filter(d => d.lvs === g).reduce((s, d) => s + d.injured, 0)) },
        { label: 'Uninjured', backgroundColor: PALETTE.pink,  data: groups.map(g => data.filter(d => d.lvs === g).reduce((s, d) => s + d.uninjured, 0)) },
        { label: 'Unknown',   backgroundColor: PALETTE.slate, data: groups.map(g => data.filter(d => d.lvs === g).reduce((s, d) => s + d.unknownStatus, 0)) }
      ]
    },
    options: {
      indexAxis: 'y',
      scales: {
        x: { stacked: true, grid: { color: gridColor(0.08) } },
        y: { stacked: true, grid: { color: gridColor(0.06) } }
      },
      plugins: { title: { text: 'Outcome Breakdown by LVS (Stacked)' } }
    }
  });
}

function renderGearMatrix(data) {
  const ctx = document.getElementById('gearMatrixChart').getContext('2d');
  if (charts.risk) charts.risk.destroy();

  const combos = [
    { label: 'No Gear (LVS No + Airbag None)', filter: d => d.lvs === 'no' && d.airbag === 'none' },
    { label: 'LVS Only (Yes + None)',         filter: d => d.lvs === 'yes' && d.airbag === 'none' },
    { label: 'Airbag Some (any LVS)',         filter: d => d.airbag === 'some' },
    { label: 'LVS + Airbag All (Yes + All)',  filter: d => d.lvs === 'yes' && d.airbag === 'all' },
    { label: 'Unknown (LVS/Airbag Unknown)',  filter: d => d.lvs === 'unknown' || d.airbag === 'unknown' }
  ];

  const rates = combos.map(c => {
    const subset = data.filter(c.filter);
    const total = subset.reduce((s, d) => s + d.involvedCount, 0);
    const dead = subset.reduce((s, d) => s + d.dead, 0);
    return total > 0 ? Math.round((dead / total) * 100) : 0;
  });

  charts.risk = new Chart(ctx, {
    type: 'bar',
    data: {
      labels: combos.map(c => c.label),
      datasets: [{
        label: 'Fatality Rate %',
        data: rates,
        backgroundColor: [PALETTE.slate, PALETTE.pink, PALETTE.blush, PALETTE.berry, PALETTE.ink]
      }]
    },
    options: {
      plugins: { title: { text: 'Survival Risk Matrix (% Mortality)' } },
      scales: {
        x: { grid: { color: gridColor(0.06) } },
        y: { beginAtZero: true, grid: { color: gridColor(0.08) } }
      }
    }
  });
}

document.getElementById('btnFetch').addEventListener('click', startScrape);
</script>

</body>
</html>
